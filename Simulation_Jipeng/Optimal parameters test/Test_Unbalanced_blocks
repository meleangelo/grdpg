require(dplyr)
require(graphstats)
require(mclust)
require(ggplot2)


# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  library(grid)
  
  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)
  
  numPlots = length(plots)
  
  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                     ncol = cols, nrow = ceiling(numPlots/cols))
  }
  
  if (numPlots==1) {
    print(plots[[1]])
    
  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))
    
    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))
      
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}


## B matrix
generateBwithCovariate <- function(latent, beta, K, d) {
  X <- matrix(rep(latent[,1]), nrow = cov, ncol = d, byrow = TRUE)
  for (k in 2:ncol(latent)) {
    X <- rbind(X, matrix(rep(latent[,k]), nrow = cov, ncol = d, byrow = TRUE))
  }
  
  Z <- rep(c(1,-1), times = K)
  ones=rep(1,times=K*2)
  Beta <- beta*(Z %*% t(Z) + ones %*% t(ones))/2
  B <- X %*% t(X) + Beta
  return(B)
}


## P matrix
generatePwithCovariate <- function(latent, beta, K, d, n, block_size, cov, covariates) {
  X <- matrix(rep(latent[,1]), nrow = block_size[1], ncol = d, byrow = TRUE)
  for (k in 2:ncol(latent)) {
    X <- rbind(X, matrix(rep(latent[,k]), nrow = block_size[k], ncol = d, byrow = TRUE))
  }
  # Z <- rep(1:cov, each = n/(K*cov), times = K)
  # Beta <- Z %*% t(Z)
  Beta <- covariates %*% t(covariates)
  Beta[Beta %in% (1:cov)^2] <- 1
  Beta[!(Beta %in% (1:cov)^2)] <- 0
  Beta <- Beta * beta
  P <- X %*% t(X) + Beta
  return(P)
}


## Generate adjacency matrix
generateA <- function(n, P, seed) {
  set.seed(seed)
  A <- matrix(0, nrow = n, ncol = n)
  for (i in 1:(n-1)) {
    for (j in (i+1):n) {
      A[i,j] <- rbinom(1, 1, P[i,j])
    }
  }
  A <- A + t(A)
  return(A)
}


## Get Ipq for GRDPG
getIpq <- function(s, d) {
  p <- which(s<abs(s[length(s)]))[1]
  if (p > d) {
    Ipq <- diag(rep(1,d))
  } else {
    Ipq <- diag(c(rep(1,p-1), rep(-1, d-p+1)))
  }
  return(Ipq)
}


## Estimate beta
estimatebeta <- function(BXhat, cov) {
  betahats <- c()
  model2 <- Mclust(diag(BXhat), ncol(BXhat)/cov, verbose = FALSE)
  c <- getClusters(model2)
  for (i in 1:(ncol(BXhat)/cov)) {
    ind <- which(c==i)
    for (j in 1:(length(ind)-1)) {
      betahats <- c(betahats, abs(BXhat[ind[j],]-BXhat[ind[j+1],]))
    }
  }
  symbol <- ifelse(BXhat[1,1]-BXhat[1,which(c==c[1])[2]]>0, 1, -1)
  betahat <- mean(betahats) * symbol
  return(betahat)
}





## Get the label of clusters
getClusters <- function(model) {
  block_assignment_probs <- data.frame(model$z)
  block_assignment_probs <- mutate(block_assignment_probs, cluster = apply(block_assignment_probs, 1, which.max))
  assignments <- block_assignment_probs$cluster
  return(assignments)
}




## Simulation
simulation_GRDPGwithCovariates <- function(latent, beta, K, d, n, block_size, block_size_cov, cov, dmax, sd=FALSE, seed=2018) {
  
  
  cat('\n\n', 'Simulation: (G)RDPG with Covariates', '\n\n\n', 'Setting Up....')
  
  ## Set Up
  set.seed(seed)
  blocks <- c()
  for (k in 1:length(block_size)) {
    blocks <- c(blocks, rep(k, block_size[k]))
  }
  blocks_cov <- c()
  for (k in 1:length(block_size_cov)) {
    blocks_cov <- c(blocks_cov, rep(k, block_size_cov[k]))
  }
  covariates <- c()
  ind <- 1
  for (k in 1:length(block_size_cov)) {
    if(k %% cov == 0) {
      ind <- 2
    }
    covariates <- c(covariates, rep(ind, block_size_cov[k]))
    ind <- 1
  }
  B <- generateBwithCovariate(latent, beta, K, d)
  P <- generatePwithCovariate(latent, beta, K, d, n, block_size, cov, covariates)
  
  cat('\n\n', 'Sampling...')
  
  
  ## Sample Network
  # g <- igraph::sample_sbm(n, B, block_size_cov)
  # A <- as_adj(g)
  
  A <- generateA(n, P, seed)
  
  cat('\n\n', 'Embedding...')
  
  ptm <- proc.time()
  
  ## ASE
  s <- gs.embed.ase(A, dmax)$D
  
  
  ## Embed
  dhat=4
  embed <- gs.embed.ase(A, dhat)
  Xhat <- embed$X %*% sqrt(diag(embed$D, nrow=dhat, ncol=dhat))
  
  
  
 
  
  ## Estiamte beta
  model <- Mclust(Xhat, verbose = FALSE) 
  muhats <- model$parameters$mean
  
  temp <- eigen(A)
  Ipq <- getIpq(temp$values, dhat)
  BXhat <- t(muhats) %*% Ipq %*% muhats
  
  betahat <- estimatebeta(BXhat, cov) 
  
  
  

  
  
  
  
  
  
  return(betahat)
}



## Example
seed <- 2018
latent <- cbind(0.425, 0.525)
#latent <- cbind(0.2, 0.4, 0.7, 0.8)                # d = 1
#latent <- cbind(c(0.63, -0.14), c(0.69, 0.13))     # d = 2
beta <- 0.15
K <- 2
d <- 1
n <- 2000
#pi <- rep(1/K, K)  # Balanced 
#pi <- c(0.3, 0.7)  # Unbalanced
pi_cov <- rep(1/(K*2), K*2)                      # Balanced 
#pi_cov <- c(0.3*0.4, 0.3*0.6, 0.7*0.4, 0.7*0.6)  # Unbalanced
#block_size <- round(pi * n)
block_size_cov <- round(pi_cov * n)
cov <- 2     # Possible value of covariate, e.g. binary = 2
dmax <- 5


## Simulation
pi0=c(0.1,1-0.1)
bandwidth=0.025
block_size <- round(pi0 * n)
betahat=simulation_GRDPGwithCovariates(latent, beta, K, d, n, block_size, block_size_cov, cov, dmax)
error=abs(betahat-beta)
for (pi_ in seq(0.1+bandwidth,0.5,bandwidth)){
  pi=c(pi_,1-pi_)
  block_size <- round(pi * n)
  betahat=simulation_GRDPGwithCovariates(latent, beta, K, d, n, block_size, block_size_cov, cov, dmax)
  error=c(error,abs(betahat-beta))
}
plot(seq(0.1,0.5,0.025),error,xlab='Proportion of first block',ylab = 'beta error',main = 'n=2000, p=0.425, beta=0.15')
